###HashMap原理 
	回答：底层是数组加链表实现的哈希表。允许null作为键，null作为值。线程不安全。 
	为什么用数组+链表实现？ 
	利用拉链法解决冲突：把所有的同义词用单链表链接起来。
	该方法下，哈希表每个单元中存放的不再是元素本身，而是相应同义词单链表的头指针。 

>相关知识点

>- HashMap维护了一个Entry数组，Entry内部类有key,value，hash和next四个字段，其中next也是一个Entry类型。

>- 可以将Entry数组理解为一个个的散列桶。每一个桶实际上是一个单链表。当执行put操作时，会根据key的hashcode定位到相应的桶。

>- 遍历单链表检查该key是否已经存在，如果存在，覆盖该value，反之，新建一个新的Entry，并放在单链表的头部。

>- 当通过传递key调用get方法时，它再次使用key.hashCode()来找到相应的散列桶，然后使用key.equals()方法找出单链表中正确的Entry，然后返回它的值。

>- HashMap：线程不同步。根据key的hashcode进行存储，内部使用静态内部类Node的数组进行存储，默认初始大小为16，每次扩大一倍。当发生Hash冲突时，采用拉链法（链表）。 
  可以接受为null的键值(key)和值(value)。JDK
  1.8中：当单个桶中元素个数大于等于8时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现。由此来防止hashCode攻击。 

###Java运行时数据区域  
	回答：包括程序计数器、JVM栈、本地方法栈、方法区、堆     

>相关知识点

>- 本地方法栈：和jvm栈所发挥的作用类似，区别是jvm栈为jvm执行java方法（字节码）服务，而本地方法栈为jvm使用的native方法服务。

>- JVM栈：局部变量表、操作数栈、动态链接、方法出口。

>- 方法区：用于存储已被虚拟机加载的类信息，常量、静态变量、即时编译器编译后的代码等。

>- 堆：存放对象实例。

###怎样判断是否需要收集？ 
	回答：
	引用计数法：对象没有任何引用与之关联(无法解决循环引用) 
	
	可达性分析法：通过一组称为GC Root的对象为起点,从这些节点向下搜索，
				如果某对象不能从这些根对象的一个(至少一个)所到达,则判定该对象应当回收。 

  

###什么可作为GCRoot的对象？ 
	虚拟机栈中引用的对象
	本地方法栈中JNI引用的对象
	方法区中类静态属性引用的对象
	方法区中类常量引用的对象

###Spring IOC/AOP？   
>AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。 

>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。

>也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。

>对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。
 
>依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。

>当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，**创建被调用者的工作不再由调用者来完成，因此称为控制反转**;**创建被调用者
实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入**。

>不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:一个人(Java实例，调用者)需要一把斧子(Java实例，被调用者)。

>AOP使用场景

>- Authentication 权限
>- Caching 缓存
>- Context passing 内容传递
>- Error handling 错误处理
>- Lazy loading　懒加载
>- Debugging　　调试
>- logging, tracing, profiling and monitoring　记录跟踪　优化　校准
>- Performance optimization　性能优化
>- Persistence　　持久化
>- Resource pooling　资源池
>- Synchronization　同步
>- Transactions 事务
